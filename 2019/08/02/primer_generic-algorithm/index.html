<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>primer_泛型算法 | Gnique Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Gniq">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.png">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div class="single">

<div id="page">
<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/post_cover.jpeg)" data-stellar-background-ratio="0.5">
  <div class="overlay">
  <div class="page-title">
    <div class="avatar"><a href="/"><img src="/images/avatar.jpeg"></a></div>
    <span>2019-08-02</span>
    <h2>primer_泛型算法</h2>
    <div class="tags"><i class="fa fa-tag"></i><a class="tag-link" href="/tags/cpp-primer/" rel="tag">cpp_primer</a></div>
    </div>
</div>
</div>

<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <p><strong>泛型算法</strong>（generic algorithm）可用于不同类型的容器和不同元素，而无需为每一种容器定制过多的操作。</p>
<a id="more"></a>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一般情况下这些算法遍历有两个迭代器组成的范围，来对元素进行处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">auto</span> result=<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),val); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"the value you look for "</span>&lt;&lt;(result==vec.cend())? <span class="string">"is not present"</span> : <span class="string">"is present"</span>)</span><br></pre></td></tr></table></figure>

<p>在这里<code>find</code>如果没有找到则返回<code>vec.end()</code>也就是第二个参数，如果找到了就返回指向找到的第一个数的迭代器。</p>
<p>由于<code>find</code>操作的是迭代器，所以对其它任何容器都可以使用。</p>
<p>甚至是内置数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[]=&#123;<span class="number">1</span>,<span class="number">24</span>,<span class="number">32</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val=<span class="number">24</span>;</span><br><span class="line"><span class="keyword">auto</span> result=<span class="built_in">find</span>(<span class="built_in">begin</span>(ia),<span class="built_in">end</span>(ia),val); <span class="comment">//使用begin和end函数来指向首元素和尾元素后的位置</span></span><br></pre></td></tr></table></figure>

<p>此外也可以缩小迭代器指向的范围，来传入参数进行查找：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result=<span class="built_in">find</span>(ia+<span class="number">1</span>,ia+<span class="number">4</span>,val);</span><br></pre></td></tr></table></figure>

<p>算法由于运行与迭代器之上，所以它永远不可能改变容器的大小。</p>
<h3 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h3><h4 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h4><p><code>find</code>和<code>count</code>函数属于只读算法，它们不会改变元素。还有一个<code>accumulate</code>函数，接受三个参数，制定了范围和求和的初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=accumulate(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h5><p>由于<code>accumulate</code>函数将第三个参数作为求和起点，意味着容器内的元素必须能够加到和<code>sum</code>的类型上。</p>
<p>加入我们要连接容器里的<code>string</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum=accumulate(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="built_in">string</span>(<span class="string">""</span>));</span><br></pre></td></tr></table></figure>

<p>注意这里”求和“的过程中，使用了<code>string</code>的+运算符，并且第三个参数是显式创建了一个空串，如果我们不显式创建空串，就会编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum=accumulate(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="string">""</span>);</span><br></pre></td></tr></table></figure>

<p>因为这里第三个参数是和的初始值，也就是说保存和的对象的类型是<code>const char*</code>，而不是<code>string</code>。而<code>const char*</code>类型没有定义+运算符，所以会发生错误。</p>
<h5 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h5><p><code>equal</code>算法用于确定两个序列是否具有相同的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equal(list1.cbegin(),list1.cend(),list2.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>

<p>在这里要假定第二个序列至少与第一个序列一样长。</p>
<h4 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h4><p>算法<code>fill</code>接受一对迭代器表示范围，还有一个参数表示填入的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>只要我们给定一个有效的序列，那么<code>fill</code>操作就是安全的。</p>
<h5 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h5><p><code>fill_n</code>算法接受单个迭代器和一个计数值，以及一个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec.fill_n(elem,n,val);</span><br></pre></td></tr></table></figure>

<p>注意这里写入元素时，要保证从<code>elem</code>开始要有至少<code>n</code>个元素，不然会出现异常。</p>
<h5 id="back-inserter操作"><a href="#back-inserter操作" class="headerlink" title="back_inserter操作"></a>back_inserter操作</h5><p><code>back_inserter</code>接受一个指向容器的引用，返回一个与该容器绑定的迭代器。通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将具有给定值的元素添加到容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//空容器</span></span><br><span class="line"><span class="keyword">auto</span> it=back_inserter(vec);</span><br><span class="line">*it=<span class="number">42</span>; <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure>

<p>使用<code>back_inserter</code>为容器连续赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(back_inserter(vec),<span class="number">10</span>,val);</span><br></pre></td></tr></table></figure>

<p>这里进行了迭代，每次调用<code>back_inserter</code>来添加一个新的迭代器，并通过这个迭代器赋值。</p>
<h5 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h5><p><code>copy</code>函数接受三个参数，前两个表示范围，第三个表示目的序列的起始位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">int</span> a2[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">sizeof</span>(a1)/<span class="keyword">sizeof</span>(*a1)]; <span class="comment">//创建同样大小的数组</span></span><br><span class="line"><span class="keyword">auto</span> result=copy(<span class="built_in">begin</span>(a1),<span class="built_in">end</span>(a1),a2);</span><br></pre></td></tr></table></figure>

<p>这里<code>copy</code>返回的是迭代器自增完毕后的位置，也就是<code>a2</code>的拷贝序列后的第一个位置。</p>
<p>另外还有<code>replace</code>算法，将序列中等于给定值的元素替换为新的值，前两个是一对迭代器指定输入序列，另一个是给定值，另一个是新值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(<span class="built_in">list</span>.<span class="built_in">begin</span>(),<span class="built_in">list</span>.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们想要原序列保持不变，并且使用新的容器来保存改变后的序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(<span class="built_in">list</span>.<span class="built_in">begin</span>(),<span class="built_in">list</span>.<span class="built_in">end</span>(),back_inserter(vec),<span class="number">0</span>,<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h4 id="重排容器元素"><a href="#重排容器元素" class="headerlink" title="重排容器元素"></a>重排容器元素</h4><p>假设我们有一个句子里面有重复的单词：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mason has a beautiful doll with a red hat</span><br></pre></td></tr></table></figure>

<p>我们想要把句子中的单词不重复的提取出来，就可以先使用<code>sort</code>算法进行排列，然后使用<code>unique</code>生成一个没有重复单词的序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elemDups</span><span class="params">(<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; &amp;slist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(slist.<span class="built_in">begin</span>(),slist.<span class="built_in">end</span>()); <span class="comment">//使用字典序排序</span></span><br><span class="line">    <span class="keyword">auto</span> end_unique=unique(slist.<span class="built_in">begin</span>(),slist.<span class="built_in">end</span>());</span><br><span class="line">    slist.erase(end_unique,slist.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>unique</code>重新排输入序列，返回一个指向最后一个不重复元素之后的迭代器，这时<code>erase</code>擦除的范围就从这里开始。</p>
<p><code>unique</code>操作后的序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a beautiful doll has hat mason red with a</span><br></pre></td></tr></table></figure>

<p>那么<code>end_unique</code>就指向<em>a</em>。</p>
<h3 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h3><p>在上面，调用<code>sort</code>函数时，比较是使用的<code>&lt;</code>运算符来进行比较，如果我们要对类类型的元素进行排序就需要定制<code>sort</code>的操作。</p>
<h4 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h4><p>如果我们需要按长度排序单词，长度相同的使用字典序。为此，我们为<code>sort</code>传入第三个参数，即<strong>谓词</strong>（predicate）。</p>
<p>谓词分两类：<strong>一元谓词</strong>（unary predicate）和<strong>二元谓词</strong>（binary predicate）。</p>
<p>接受二元谓词参数的<code>sort</code>用这个谓词来代替&lt;来比较元素，我们可以使用<code>isShorter</code>来代替它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再传入<code>sort</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(slist.<span class="built_in">begin</span>(),slist.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>

<p>注意在传入了<code>isShorter</code>之后，就不能按字典序进行排序了。</p>
<p>同时如果我们想要对相同长度的串进行字典序排序，可以使用<code>stable_sort</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elimDups(sentence);</span><br><span class="line">stable_sort(sentence.<span class="built_in">begin</span>(),sentence.<span class="built_in">end</span>(),isShorter);</span><br></pre></td></tr></table></figure>

<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>假设我们想要获取一个序列中大于指定长度的单词的个数，那我们可以先对序列进行长度排序，然后找到第一个大于给定长度的元素的位置，就可以得知个数了。</p>
<p>所以我们可以使用<code>find_if</code>算法来查找这个元素，<code>find_if</code>是接受谓词的，那么我们可以定义一个函数接受一个<code>string</code>和长度，但是这就是一个二元谓词了，<code>find_if</code>只接受一元谓词，所以需要另行办法。</p>
<h5 id="介绍lambda"><a href="#介绍lambda" class="headerlink" title="介绍lambda"></a>介绍lambda</h5><p>我们可以向算法传递任意的<strong>可调用对象</strong>（callable object）。如果一个对象或者一个表达式可以使用调用运算符，那么称它为可调用的。即<code>e</code>有<code>e(args)</code>。</p>
<p>我们学习过的可以使用调用运算符的除了函数、函数指针、重载了调用运算符的类类型，就是lambda表达式。</p>
<p>一个lambda表达式具有以下形式：<br><em>[capture list]   (parameter list)     -&gt;    return type    {function body}</em></p>
<p>其中<em>capture list</em>是值lambda表达式所在函数的局部变量列表（不使用这些局部变量时为空），其他三个跟普通函数无异，注意这里lambda使用尾置返回。</p>
<p>可以忽略参数列表和返回类型，但是必须包含捕获列表和函数体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[] &#123;<span class="keyword">return</span> <span class="number">10</span>;&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们就定义了一个可调用对象<code>f</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;f()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>如果lambda包含任何单一<code>return</code>语句之外的内容，且没有指定返回类型，则返回<code>void</code>。</p>
<h5 id="向lambda传参数"><a href="#向lambda传参数" class="headerlink" title="向lambda传参数"></a>向lambda传参数</h5><p>写一个与<code>isShorter</code>作用相同的lambda：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span><br><span class="line">&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话就可以将这个lambda传入<code>stable_sort</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">            [] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span><br><span class="line">              &#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h5><p>在前面我们为求大于给定长度的元素个数指定一个函数<code>biggies</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; svec,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    elemDups(svec); <span class="comment">//消除重复元素</span></span><br><span class="line">    stable_sort(svec.<span class="built_in">begin</span>(),svec.<span class="built_in">end</span>(),isShorter()); <span class="comment">//重新按长度和字典序排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，使用lambda来捕获局部变量<code>sz</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sz] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;sz;&#125;;</span><br></pre></td></tr></table></figure>

<p>只有在lambda捕获了所在函数内的局部变量，才能够使用这些局部变量。</p>
<p>这样我们就可以使用这个lambda来调用<code>find_if</code>了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res=find_if(svec.<span class="built_in">begin</span>(),svec.<span class="built_in">end</span>(),[sz] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;sz;&#125; );</span><br></pre></td></tr></table></figure>

<p>接着使用迭代器来计算有多少个大于指定值的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> count=svec.<span class="built_in">end</span>()-res;</span><br></pre></td></tr></table></figure>

<p>最后我们可以使用<code>for_each</code>算法，接受一个可调用对象来打印这些数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(res,svec.<span class="built_in">end</span>(),[](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;&#125;);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>这里<code>for_each</code>对输入序列的每个元素调用此对象。</p>
<h4 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h4><h5 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h5><p>捕获方式可以是值或者引用。采用值捕获的前提是变量可以拷贝。并且被捕获的变量是在lambda创建时拷贝，而不是调用时拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fun&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">13</span>;</span><br><span class="line">    <span class="keyword">auto</span> f=[a] &#123;<span class="keyword">return</span> a;&#125;;</span><br><span class="line">    a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">auto</span> g=f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>g</code>的值仍为13，因为在创建lambda时就已经拷贝了<code>a</code>的值，调用的时候返回的也是13。</p>
<h5 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fun&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">auto</span> f=[&amp;a] &#123;<span class="keyword">return</span> a;&#125;;</span><br><span class="line">    a=<span class="number">14</span>;</span><br><span class="line">    <span class="keyword">auto</span> j=f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用捕获有一个需要注意的地方，由于lambda引用的是局部变量，所以在函数结束时使用lambda时，局部变量就已经失效了。</p>
<p>我们利用引用捕获来重写<code>biggies</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz,ostream&amp; os=<span class="built_in">cout</span>,<span class="keyword">char</span> c=<span class="string">" "</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//重排的代码</span></span><br><span class="line">    for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[&amp;os,c] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;os&lt;&lt;s&lt;&lt;c;&#125;);</span><br><span class="line">    <span class="comment">//引用os和c来对每个串进行输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以用函数返回一个lambda，返回一个可调用对象。但是返回的lambda不能包含引用捕获，这与普通函数不能返回局部变量类似。</p>
<p>保持lambda变量捕获的简单性：在捕获普通变量如<code>int</code>、<code>string</code>或其他非指针类型时，可以采取简单的值捕获。如果我们捕获指针或者迭代器，就必须确保在执行lambda时，指针或迭代器指向的对象仍然存在。</p>
<h5 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h5><p>我们可以让指示编译器根据lambda体中的代码来推断需要捕获的变量，如果是值捕获，则使用<code>=</code>，如果是引用捕获，则使用<code>&amp;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res=find_if(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[=] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;<span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;sz;&#125;) </span><br><span class="line">    <span class="comment">//这里根据lambda体推断应该捕获sz</span></span><br></pre></td></tr></table></figure>

<p>还可以混合使用隐式和显式捕获：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[=,&amp;os] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;os&lt;&lt;s&lt;&lt;c;&#125;);</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[&amp;,c] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;os&lt;&lt;s&lt;&lt;c;&#125;);</span><br></pre></td></tr></table></figure>

<p>混合使用时，显式捕获跟隐式捕获变量的方式必须不同。</p>
<p><img src="/img/capturelist.png" alt=""></p>
<h5 id="指定lambda返回类型"><a href="#指定lambda返回类型" class="headerlink" title="指定lambda返回类型"></a>指定lambda返回类型</h5><p>默认情况下如果lambda体包含除<code>return</code>之外的任何语句，则编译器假定返回<code>void</code>，因为编译器不能从其他语句中推出返回类型。</p>
<p>我们可以使用<code>transform</code>算法和lambda来将序列中的元素绝对值化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec.<span class="built_in">begin</span>(),[](<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i&lt;<span class="number">0</span> ? -i : i;&#125;);</span><br></pre></td></tr></table></figure>

<p>算法接受一个输入序列，对序列中的每个元素执行可调用对象（这里是lambda），并将结果写入目的位置开始后的序列。</p>
<p>如果我们改成<code>if</code>语句将会发生错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec.<span class="built_in">begin</span>(),[] (<span class="keyword">int</span> i) &#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#125; <span class="keyword">return</span> -i;<span class="keyword">else</span> <span class="keyword">return</span> i;);</span><br></pre></td></tr></table></figure>

<p>因为这里默认返回的是<code>int</code>，但是实际返回的是<code>int</code>。</p>
<p>所以我们使用尾置返回类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),vec.<span class="built_in">begin</span>(),[] (<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123;<span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> -i;<span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><p>对于只在少数地方使用的简单操作，我们可以使用lambda，但是如果是多次使用的复杂操作，仍然选择函数。</p>
<p>另外，如果捕获列表为空，则最好使用函数来代替。如果需要捕获局部变量，有时候函数并不是一个好的选择。</p>
<h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h5><p><code>bind</code>函数更像是一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable=bind(callable,arg_list);</span><br></pre></td></tr></table></figure>

<p>调用<em>newCallable</em>时，会调用<em>callable</em>，向它传递<em>arg_list</em>里的参数。</p>
<p>这里<em>arg_list*里面可能包含形如</em>_n<em>的参数，</em>_n<em>在</em>arg_list<em>中的位置表示传入<code>newCallable</code>的第</em>n*个参数在传入<code>callable</code>的参数列表中的位置。</p>
<p>这里我们将<code>bind</code>与<code>check_size()</code>结合起来举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> check5=bind(check_size(),_1,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>在这里<code>check_size</code>函数接受两个参数，一个<code>string</code>和一个<code>int</code>。那么传入<code>check5</code>的就只有一个<code>string</code>了。这里<code>_1</code>表示传入<code>check5</code>的第<code>_1</code>个也是唯一一个<code>string</code>参数位于<code>check_size</code>的参数列表的第一个位置，也就是说<code>check_size</code>的函数原型是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>也就是说对于这样的调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g=bind(f,_2,s,_1);</span><br></pre></td></tr></table></figure>

<p>存在这样的映射：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g(_1,_2);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(_2,s_1);</span><br></pre></td></tr></table></figure>

<p>现在我们就可以使用<code>check5</code>来检查字符串的长度了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"mason"</span>;</span><br><span class="line"><span class="keyword">bool</span> res=check5(s);</span><br></pre></td></tr></table></figure>

<p>于是我们可以用<code>bind</code>操作来替代lambda捕获：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res=find_if(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),bind(check_size(),_1,sz));</span><br></pre></td></tr></table></figure>

<p>当<code>find_if</code>对<code>words</code>的每个<code>string</code>调用<code>bind</code>返回的可调用对象时，这些可调用对象就会调用<code>check_size</code>，将<code>string</code>和<code>sz</code>传递给他，从而实现比较。</p>
<p>另外由于<em>_n</em>定义在名为<code>placeholders</code>的命名空间内，所以我们需要声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br></pre></td></tr></table></figure>

<h5 id="bind的重排"><a href="#bind的重排" class="headerlink" title="bind的重排"></a>bind的重排</h5><p>我们可以使用<code>bind</code>来颠倒<code>isShorter</code>的含义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),isShorter); <span class="comment">//从短到长排序</span></span><br><span class="line">sort(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),bind(isShorter,_2,_1)); <span class="comment">//从长到短排</span></span><br></pre></td></tr></table></figure>

<h5 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h5><p>默认情况下<code>bind</code>的那些不是占位符的参数被拷贝到<code>bind</code>返回的可调用对象中。</p>
<p>为了替换用于打印每个元素的lambda:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),[&amp;os,c] (<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;os&lt;&lt;s&lt;&lt;c;&#125;);</span><br></pre></td></tr></table></figure>

<p>编写一个<code>print</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os,<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os&lt;&lt;s&lt;&lt;c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们直接使用参数的拷贝来生成可调用对象就是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),bind(<span class="built_in">print</span>,os,_1,<span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<p>这里不能拷贝一个<code>ostream</code>对象，这是可以使用标准库的<code>ref</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),bind(<span class="built_in">print</span>,ref(os),_1,<span class="string">" "</span>));</span><br></pre></td></tr></table></figure>

<p>这里<code>ref</code>返回一个对象的引用。</p>
<h3 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h3><h4 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h4><p>插入器有三种类型：<br><img src="/img/inserter.png" alt=""></p>
<p>当我们调用<code>inserter(c,iter)</code>时，我们得到一个插入迭代器，我们通过它来插入元素时，会插入到<code>iter</code>原来指向的元素之前的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it=inserter(c,iter);</span><br><span class="line">*it=val;</span><br></pre></td></tr></table></figure>

<p>效果与下面的代码一样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">it=c.insert(it,val); <span class="comment">//it指向新加入的元素</span></span><br><span class="line">++it;</span><br></pre></td></tr></table></figure>

<p>在调用<code>inserter(c,iter)</code>时，我们插入的元素总是在<code>iter</code>原来指向的元素之前，注意这里的<code>iter</code>指向的位置没有变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2;</span><br><span class="line">copy(lst1.<span class="built_in">begin</span>(),lst1.<span class="built_in">end</span>(),inserter(lst2,lst2.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">//lst2的元素是：1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>如果我们使用<code>front_inserter</code>的话，插入的元素总是在首元素之前，调用的是<code>push_front</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy(lst1.<span class="built_in">begin</span>(),lst1.<span class="built_in">end</span>(),front_inserter(lst3));</span><br><span class="line"><span class="comment">//得到的元素是：4 3 2 1</span></span><br></pre></td></tr></table></figure>

<h4 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h4><p>尽管<code>iostream</code>不是容器类型，但是标准库定义了可以用于这些类型对象的迭代器。<code>istream_iterator</code>读取输入流，<code>ostream_iterator</code>读取输出流。</p>
<h5 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h5><p>创建一个流迭代器时，必须指定要从流读取的对象的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; <span class="comment">//默认初始化流迭代器，可以当做尾后值使用</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"file_name"</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">str_it</span><span class="params">(in)</span></span>; <span class="comment">//从“file_name"读取string</span></span><br></pre></td></tr></table></figure>

<p>使用迭代器从<code>cin</code>读取数据并存入<code>vector</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;</span><br><span class="line"><span class="keyword">while</span>(int_it!=eof)</span><br><span class="line">    <span class="built_in">vector</span>.push_back(*ini_it++); <span class="comment">//使用后置递增，读取旧值，然后迭代器递增</span></span><br></pre></td></tr></table></figure>

<p>这里<code>eof</code>是一个空的迭代器，如果读取结束，也就是迭代器的值与尾后迭代器的值相等。</p>
<p>我们可以重写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; int_it(cin),eof;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(int_it,eof)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>vector</code>的构造函数，从<code>cin</code>读取数据直到文件尾或者遇到不是<code>int</code>的数据为止。在读取的过程中，<code>int_it</code>持续自增。</p>
<p>以下是一些<code>istream_iterator</code>的操作：<br><img src="/img/istream_iterator.png" alt=""></p>
<p>另外我们还可以向某些算法传入流迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; int_it(cin),eof;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;accumulate(int_it,eof,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这个调用会计算从输入流读取的所有<code>int</code>的和。</p>
<h5 id="使用ostream-iterator"><a href="#使用ostream-iterator" class="headerlink" title="使用ostream_iterator"></a>使用ostream_iterator</h5><p>常用操作</p>
<p><img src="/img/ostream_iterator.png" alt=""></p>
<p>输出一个序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_it</span><span class="params">(<span class="built_in">cout</span>,<span class="string">" "</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:ivec)</span><br><span class="line">    *out_it++=i; <span class="comment">//将元素写到cout中</span></span><br></pre></td></tr></table></figure>

<p>循环也可以重写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:ivec)</span><br><span class="line">    out_it=e;</span><br></pre></td></tr></table></figure>

<p>是一样的，因为<code>*</code>和<code>++</code>不对迭代器做任何事情。</p>
<p>使用<code>copy</code>打印序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),out_iter);</span><br></pre></td></tr></table></figure>

<h5 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h5><p>如果有类类型定义了<code>&lt;&lt;</code>和<code>&gt;&gt;</code>，那么也可以使用流迭代器来操纵它们：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;sales_item&gt; item_it(cin),eof;</span><br><span class="line"><span class="function">ostream_iterator&lt;sales_item&gt; <span class="title">item_out</span><span class="params">(<span class="built_in">cout</span>,<span class="string">" "</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h4><p>反向迭代器就是从尾元素向首元素移动的迭代器。</p>
<p>除了<code>forward_list</code>之外，其他的顺序容器都支持反向迭代器。</p>
<p>下图展示了四种迭代器：</p>
<p><img src="/img/reverse_iterator.png" alt=""></p>
<p>逆序打印序列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> riter=ivec.rbegin();riter!=ivec.rend();riter++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*riter&lt;&lt;<span class="string">" "</span>;</span><br></pre></td></tr></table></figure>

<p>同时结合<code>sort</code>来排递减序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(ivec.rbegin(),ivec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h5 id="反向迭代器和其他迭代器的关系"><a href="#反向迭代器和其他迭代器的关系" class="headerlink" title="反向迭代器和其他迭代器的关系"></a>反向迭代器和其他迭代器的关系</h5><p>假设我们有一个用逗号分隔的单词列表，我们希望打印第一个单词：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> comma=<span class="built_in">find</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>(),<span class="string">" "</span>); <span class="comment">//找到comma</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(str.<span class="built_in">begin</span>(),comma)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//截取首元素到comma的部分</span></span><br></pre></td></tr></table></figure>

<p>如果要打印最后一个单词，可以使用反向迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> rcomma=<span class="built_in">find</span>(str.rbegin(),str.rend(),<span class="string">","</span>);</span><br></pre></td></tr></table></figure>

<p>接着我们输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(str.cbegin(),rcomma);</span><br></pre></td></tr></table></figure>

<p>事实上得到的结果是错误的！假如我们的列表是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crazy,ass</span><br></pre></td></tr></table></figure>

<p>得到的单词会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssa</span><br></pre></td></tr></table></figure>

<p>这是很多人没有想到的，因为<code>string</code>的元素是字符而不是整个单词。</p>
<p>所以这里我们需要让<code>rcomma</code>迭代器正向移动，对<code>romma</code>使用<code>base</code>函数来返回一个普通的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">string</span>(rcomma.base(),str.<span class="built_in">end</span>())&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>注意这里使用<code>base</code>之后，返回的迭代器就指向逗号之后的第一个元素。</p>
<p>反向迭代器和普通迭代器的关系可以由下图反应：<br><img src="/img/rev_it.png" alt=""></p>
<p><code>rcomma</code>和<code>rcomma.base()</code>指向不同的元素，<code>line.rbegin()</code>和<code>line.end()</code>也指向不同的元素。注意左闭合区间。</p>
<h3 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h3><p>迭代器的类别：<br><img src="/img/it_cate.png" alt=""></p>
<p>输入迭代器：<br><img src="/img/input_it.png" alt=""></p>
<p>递增输入迭代器可能会导致所有其他指向流的迭代器失效，所以不能保证输入迭代器的状态可以保存下来并用来访问元素。输入迭代器只用于顺序访问，算法<code>find</code>和<code>accumulate</code>要求输入迭代器，<code>istream_iterator</code>也是一种输入迭代器。</p>
<p>输出迭代器：</p>
<p><img src="/img/output_it.png" alt=""></p>
<p>只能向输出迭代器赋值一次，用作目的位置的迭代器通常都是输出迭代器。<code>copy</code>的第三个函数就是输出迭代器，包括<code>ostream_iterator</code>。</p>
<p>前向迭代器支持输入和输出的所有操作，可以读写元素，只能往一个方向移动，我们可以保存前向迭代器的状态。</p>
<p>双向迭代器可以正反读写序列中的元素，还支持前置和后置递减运算符。支持前向迭代器的所有操作，算法<code>reverse</code>要求双向迭代器。</p>
<p>随机访问迭代器支持双向迭代器的所有操作。<br><img src="/img/random_it.png" alt=""></p>
<h4 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h4><p>大多数算法具有以下四种形式：</p>
<p><img src="/img/algandargs.png" alt=""></p>
<p>这里的<code>beg</code>和<code>end</code>表示的是输入的范围，而<code>dest</code>，<code>beg2</code>和<code>end2</code>则指示目的位置和第二个范围。</p>
<p>如果<code>dest</code>是指向容器的迭代器，那么会把输出数据写入到已存在的元素当中，当然更多情况下，<code>dest</code>是一个插入迭代器，为容器添加新元素。</p>
<p>而接受<code>beg2</code>的算法假设从<code>beg2</code>开始的序列至少与<code>beg</code>到<code>end</code>的序列一样大。</p>
<h4 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h4><h5 id="一些算法提供重载形式传递谓词"><a href="#一些算法提供重载形式传递谓词" class="headerlink" title="一些算法提供重载形式传递谓词"></a>一些算法提供重载形式传递谓词</h5><p>一些算法接受谓词参数来代替<code>&lt;</code>或<code>=</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg,<span class="built_in">end</span>);</span><br><span class="line">unique(beg,<span class="built_in">end</span>,comp); <span class="comment">//使用comp比较元素</span></span><br></pre></td></tr></table></figure>

<p>第一个调用元素类型的<code>=</code>运算符，第二个调用<code>comp</code>函数来进行判断。</p>
<h5 id="if版本的算法"><a href="#if版本的算法" class="headerlink" title="_if版本的算法"></a>_if版本的算法</h5><p>接受一个元素值的算法通常有另一个不同名的版本，接受一个谓词。且这种算法具有附加的<code>_if</code>前缀：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg,<span class="built_in">end</span>,val);</span><br><span class="line">find_if(beg,<span class="built_in">end</span>,pred); <span class="comment">//谓词pred</span></span><br></pre></td></tr></table></figure>

<h5 id="区分拷贝元素的版本和不拷贝的"><a href="#区分拷贝元素的版本和不拷贝的" class="headerlink" title="区分拷贝元素的版本和不拷贝的"></a>区分拷贝元素的版本和不拷贝的</h5><p>一般的，重排元素后会将元素写回输入序列中去，也可以指定一个目的位置，这类算法后一般带<code>_copy</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg,<span class="built_in">end</span>);</span><br><span class="line">reverse_copy(beg,<span class="built_in">end</span>,dest);</span><br></pre></td></tr></table></figure>

<p>一些算法同时支持<code>_copy</code>和<code>_if</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remove_if(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),[] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i%<span class="number">2</span> ;&#125;);  <span class="comment">//删除奇数元素</span></span><br><span class="line">remove_copy_if(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),back_inserter(v2),[] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i%<span class="number">2</span> ;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p><code>list</code>和<code>forward_list</code>定义了几个<strong>成员函数</strong>版本的算法，特别是<code>sort</code>、<code>merge</code>、<code>remove</code>、<code>reverse</code>和<code>unique</code>。因为通用版本要求随机访问迭代器，所以不能用于<code>list</code>和<code>forward_list</code>，因为这两种类型提供双向迭代器和前向迭代器。</p>
<p>对于其他的通用算法不建议用于这两种容器，相对于成员函数形式来讲代价太高。</p>
<p><img src="/img/list_it.png" alt=""></p>
<p><img src="/img/list_it2.png" alt=""></p>
<p><code>splice</code>成员，为链表数据结构通用：</p>
<p><img src="/img/list_splice.png" alt=""></p>
<p>注意链表的某些特有操作会改变容器，比如<code>remove</code>和<code>unique</code>。</p>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover prev lx-cover-sm" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/footer-l.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/08/05/primer_associative-container/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>primer_...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover next lx-cover-sm" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/footer-r.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/07/28/primer_sequential-container/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>primer_...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>

</div>

<footer>
  <div>
  Copyright &copy; 2019.<a href="/">Gnique Explorer</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="Gniq"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>Gniq</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>Pages</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>Friends</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
