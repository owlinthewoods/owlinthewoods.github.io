<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>primer_顺序容器 | Gnique Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Gniq">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>
<body>
<div class="single">

<div id="page">
<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/post_cover.jpeg)" data-stellar-background-ratio="0.5">
  <div class="overlay">
  <div class="page-title">
    <div class="avatar"><a href="/"><img src="/images/avatar.jpeg"></a></div>
    <span>2019-07-28</span>
    <h2>primer_顺序容器</h2>
    <div class="tags"><i class="fa fa-tag"></i><a class="tag-link" href="/tags/cpp-primer/" rel="tag">cpp_primer</a></div>
    </div>
</div>
</div>

<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <p>这一章是第三章的扩充，主要介绍顺序容器。</p>
<a id="more"></a>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>主要的顺序容器类型：</p>
<p><img src="/img/cateofseqcon.png" alt=""></p>
<p>由此可以看出，<code>string</code>和<code>vector</code>两种容器是的元素是连续存储的，所以想要在序列的中间插入元素是很慢的。</p>
<p>对于<code>list</code>和<code>forward_list</code>，他们在任意位置的元素添加都是迅速的，但是其代价是不支持随机访问。</p>
<p><code>deque</code>容器在中间删除和添加元素的代价（可能很高），但是在两端添加和删除元素很快。，支持随机访问。</p>
<p>相比与内置数组来讲，<code>array</code>是一种更安全和更容易使用的数组类型。</p>
<p>一些选择容器的基本原则：</p>
<p><img src="/img/stratofcon.png" alt=""></p>
<h3 id="容器库基本操作"><a href="#容器库基本操作" class="headerlink" title="容器库基本操作"></a>容器库基本操作</h3><p>由于每种容器都是模板类，在使用时，必须生成特定的容器类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;keith&gt;l1;</span><br><span class="line">vector&lt;string&gt;vec;</span><br></pre></td></tr></table></figure>

<p>顺序容器可以存取几乎任何类型的元素，包括容器类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;vec2;</span><br></pre></td></tr></table></figure>

<p>如果某些类型的元素没有默认构造函数，我们可以定义一个保存这种类型对象的元素，但是在构造容器时，不能只传递一个元素数目参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;noDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>,init)</span></span>; <span class="comment">//提供了元素初始化器</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;noDefault&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//错误，没有提供元素初始化器</span></span><br></pre></td></tr></table></figure>

<p>容器操作：</p>
<p><img src="/img/opofcon1.png" alt=""></p>
<p><img src="/img/opofcon2.png" alt=""></p>
<p><img src="/img/opofcon3.png" alt=""></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器拥有着公共的接口，即所有能够提供某种操作的迭代器对于该操作的实现方式都是相同的。</p>
<h5 id="迭代器的范围"><a href="#迭代器的范围" class="headerlink" title="迭代器的范围"></a>迭代器的范围</h5><p>迭代器的范围通常用一对迭代器来表示，即<code>begin</code>和<code>end</code>，其中<code>begin</code>指向容器中一个元素的位置，<code>end</code>则指向<strong>尾元素之后的位置</strong>。<code>begin</code>的位置严格处在<code>end</code>之前或者等于<code>end</code>。</p>
<p><code>begin</code>和<code>end</code>的这些性质使得我们可以不出差错的处理<strong>范围</strong>内的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">begin</span>!=<span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="built_in">begin</span>=val;</span><br><span class="line">    <span class="built_in">begin</span>++；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h4><p>到目前为止，我们已经使用过容器的三种类型，包括<code>size_type</code>、<code>iterator</code>和<code>const_iterator</code>。</p>
<p>另外还有类型别名，也就是为容器的元素类型指定别名，即使我们不了解元素的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="built_in">vector</span>&lt;keith&gt;::size_type st;</span><br></pre></td></tr></table></figure>

<h4 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h4><p><code>begin</code>和<code>end</code>有不同的版本，带<code>c</code>的版本返回一个<code>const_iterator</code>，带<code>r</code>的版本返回<code>reverse_iterator</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;a=&#123;<span class="string">"sasha"</span>,<span class="string">"carol"</span>,<span class="string">"peter"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1=a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2=a.cbegin();</span><br></pre></td></tr></table></figure>

<p>这里使用<code>auto</code>结合<code>begin</code>操作，而不需要显式制定类型。</p>
<p>注意这里<code>auto</code>与<code>begin</code>和<code>end</code>想结合使用时，得到的迭代器的类型取决于容器的类型。而以<code>c</code>开头的操作还是可以获得<code>const_iterator</code>的，无论容器是哪种类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a = &#123; <span class="string">"sasha"</span>,<span class="string">"carol"</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.cbegin();</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"peter"</span>;</span><br><span class="line">*it1 = s; <span class="comment">//错误，it1是一个const_iterator</span></span><br></pre></td></tr></table></figure>

<h4 id="容器定义和初始化"><a href="#容器定义和初始化" class="headerlink" title="容器定义和初始化"></a>容器定义和初始化</h4><p>除<code>array</code>之外，每个容器都定义了默认构造函数。</p>
<p><img src="/img/containerinit.png" alt=""></p>
<h4 id="拷贝容器"><a href="#拷贝容器" class="headerlink" title="拷贝容器"></a>拷贝容器</h4><p>如果我们想要拷贝一个容器到另一个容器上，那么两个容器的类型和元素类型必须相同。但是如果使用迭代器参数来拷贝指定的范围时，就不要求容器的类型相同了。而且也不要求元素类型相同了，只要被拷贝的容器的元素类型能够转换为要初始化的容器内即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a&#123; <span class="string">"sasha"</span>,<span class="string">"carol"</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>;<span class="comment">//错误，容器类型不匹配</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; c&#123;<span class="string">"peter"</span>,<span class="string">"mason"</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">d</span><span class="params">(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>())</span></span>;<span class="comment">//正确，const char*类型可以转化为string类型</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用两个迭代器指定一个被拷贝容器的子序列，然后将这两个迭代器传入构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; <span class="title">d</span><span class="params">(c.<span class="built_in">begin</span>(),it)</span></span>;<span class="comment">//这里it是一个指向c中的一个元素的迭代器</span></span><br></pre></td></tr></table></figure>

<p>由上可知，容器可以使用列表初始化，同时它们的一个构造函数还接受一个容器大小参数和元素的初始值（可选）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">10</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>,<span class="string">"mason"</span>)</span></span>;<span class="comment">//每个元素都初始化为“mason"</span></span><br></pre></td></tr></table></figure>

<p>如果元素是内置类型或者具有默认构造函数的类类型，则可以只传送容器大小参数。没有默认构造函数的类型，则不能。</p>
<h5 id="具有固定大小的array"><a href="#具有固定大小的array" class="headerlink" title="具有固定大小的array"></a>具有固定大小的array</h5><p>与内置数组一样，<code>array</code>的大小也是类型的一部分。定义<code>array</code>时，要同时指定元素类型和容器大小。</p>
<p>为了使用<code>array</code>类型，必须指定元素的大小和类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt;::size_type st;</span><br></pre></td></tr></table></figure>

<p>由于<code>array</code>的大小是类型的一部分，所以它不支持普通的构造函数。一个默认构造的<code>array</code>是非空的，它包含的元素的数目跟<code>array</code>的大小一样多。</p>
<p>所以我们要对<code>array</code>进行列表初始化的话，初始值的数目必须等于或者小于其大小。如果小于，则初始值则用来初始化靠前的序列，后面的使用值初始化。如果元素是类类型，则必须拥有默认构造函数。</p>
<p>尽管内置数组不能进行拷贝和赋值操作，但是<code>array</code>无此限制：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[]=a;<span class="comment">//错误</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; c=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,3&gt; d=c;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值和swap操作"><a href="#赋值和swap操作" class="headerlink" title="赋值和swap操作"></a>赋值和swap操作</h4><p><img src="/img/assignandswap.png" alt=""></p>
<p>在这里，<code>array</code>不支持<code>assign</code>方法。<code>assign</code>可以使用参数指定的范围内的元素（的拷贝）来替换左边容器中的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; people;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; person;</span><br><span class="line">people=person;<span class="comment">//错误，赋值时容器类型不匹配</span></span><br><span class="line">people.assign(person.<span class="built_in">begin</span>(),person.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>另外<code>assign</code>方法还可以指定容器大小并填充相同的指定元素内容到容器当中。</p>
<p><code>swap</code>方法只是交换了两个容器的数据结构，而不是元素。（除了<code>array</code>之外）</p>
<p>在进行<code>swap</code>之后，指向容器的迭代器、引用和指针仍然之前<code>swap</code>之前的所指向的那些元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec1 = &#123; <span class="string">"sasha"</span>,<span class="string">"carol"</span>,<span class="string">"mason"</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec2 = &#123; <span class="string">"peter"</span>,<span class="string">"dennis"</span>,<span class="string">"rachael"</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = vec1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = vec2.<span class="built_in">begin</span>();</span><br><span class="line">swap(vec1, vec2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it1 &lt;&lt; <span class="string">" "</span> &lt;&lt; *it2 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>我们这里得到输出结果是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sasha peter</span><br></pre></td></tr></table></figure>

<p>可见指向<code>vec1</code>的第一个元素的迭代器<code>ti1</code>并没有改变。</p>
<p>但是对于<code>string</code>来讲，使用<code>swap</code>会使这些发生改变。而对于<code>array</code>来讲，<code>swap</code>会真正交换它们的元素，也就是说迭代器、指针和引用绑定的元素不变，但是元素值会发生改变。</p>
<p><code>swap</code>由成员版本和非成员版本，统一使用非成员版本是一个好的习惯。</p>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符两边的运算对象必须是同一种容器，包含同一种元素。</p>
<p>运算符的工作方式与<code>string</code>类似：<br><img src="/img/compareop.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec3=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">vec1==vec2 <span class="comment">//正确</span></span><br><span class="line">vec3&lt;vec2 <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>注意，只有比较的元素定义了对应的比较元素，才能对两个容器进行比较。</p>
<h3 id="顺序容器特有操作"><a href="#顺序容器特有操作" class="headerlink" title="顺序容器特有操作"></a>顺序容器特有操作</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p><img src="/img/addelement.png" alt=""></p>
<h5 id="使用push-back"><a href="#使用push-back" class="headerlink" title="使用push_back"></a>使用push_back</h5><p>除了<code>array</code>和<code>forward_list</code>之外，所有的顺序容器都支持<code>push_back</code>方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;<span class="keyword">word</span>)</span><br><span class="line">&#123;</span><br><span class="line">   seq.push_back(<span class="keyword">word</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用<code>push_back</code>在<code>string</code>末尾添加字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pluralise</span><span class="params">(<span class="keyword">size_t</span> cnt,<span class="built_in">string</span> &amp;<span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">word</span>.push_back(<span class="string">'s'</span>);<span class="comment">//复数化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里追加到容器中的元素都是原来元素的拷贝。</p>
<h5 id="使用push-front"><a href="#使用push-front" class="headerlink" title="使用push_front"></a>使用push_front</h5><p><code>list</code>、<code>forward_list</code>和<code>deque</code>容器还支持<code>push_front</code>操作。</p>
<p><code>vector</code>和<code>deque</code>一样都支持元素的随机访问，但是<code>vector</code>不支持<code>push_front</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    ilist.push_back(i);</span><br></pre></td></tr></table></figure>

<h5 id="在特定位置添加元素"><a href="#在特定位置添加元素" class="headerlink" title="在特定位置添加元素"></a>在特定位置添加元素</h5><p><code>vector</code>、<code>deque</code>、<code>list</code>和<code>string</code>都支持<code>insert</code>成员来在特定位置添加元素。</p>
<p><code>insert</code>函数接受一个迭代器作为参数，并在它指定的元素之前添加元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;</span><br><span class="line">slist.insert(iter,<span class="string">"mason"</span>);</span><br></pre></td></tr></table></figure>

<p>如果我们想要在<code>vector</code>的开始位置插入元素，就可以使用<code>insert</code>成员，但是代价较高。</p>
<p><code>insert</code>函数还接受更多的参数，比如一个元素数目和值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slist.insert(slist.<span class="built_in">end</span>(),<span class="number">10</span>,<span class="string">"hi"</span>);</span><br></pre></td></tr></table></figure>

<p>还可以插入指定范围内的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slist.insert(slist.<span class="built_in">end</span>(),svec.<span class="built_in">end</span>()<span class="number">-2</span>,svec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>这里指示范围的迭代器必须是其他容器的。</p>
<p>在调用<code>insert</code>成员后，它返回指向第一个新加元素的迭代器。利用这一点我们可以在容器的某个位置反复的插入元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;</span><br><span class="line"><span class="keyword">auto</span> it=slist.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;<span class="keyword">word</span>)</span><br><span class="line">    it=slist.insert(it.<span class="keyword">word</span>);</span><br></pre></td></tr></table></figure>

<h5 id="emplace成员"><a href="#emplace成员" class="headerlink" title="emplace成员"></a>emplace成员</h5><p>三个成员<code>emplace_front</code>,<code>emplace</code>和<code>emplace_back</code>分别对应开始，某个元素之前和尾部。</p>
<p>我们调用<code>emplace</code>函数时，是将参数传给元素类型的构造函数，也就是说不是拷贝元素而是构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;keith&gt; klist;</span><br><span class="line">klist.emplace_back(<span class="string">"mason"</span>,<span class="string">"11234566"</span>); <span class="comment">//两个字符串参数传入keith的构造函数</span></span><br></pre></td></tr></table></figure>

<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>包括<code>array</code>在内的所有顺序容器都支持<code>front</code>操作，除开<code>forward_list</code>之外所有的都支持<code>back</code>操作，它们分别返回首尾元素的引用。而且我们解引用一个迭代器也可以得到指向元素的引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="keyword">auto</span> &amp;it1=*svec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> &amp;it2=svec.front();</span><br></pre></td></tr></table></figure>

<p>这里对<code>it1</code>、<code>it2</code>的操作将影响到容器内的元素。</p>
<p><img src="/img/accesselement.png" alt=""></p>
<p>注意这里访问元素的成员函数<code>front</code>，<code>back</code>，下标，<code>at</code>返回的都是元素的引用。</p>
<h5 id="安全的随机访问"><a href="#安全的随机访问" class="headerlink" title="安全的随机访问"></a>安全的随机访问</h5><p><code>string</code>,<code>vector</code>,<code>deque</code>和<code>array</code>都支持下标运算符，返回引用。使用下标运算符时一定要保证下标不越界。在使用<code>at</code>成员时，如果发生越界，会抛出以一个<code>out_of_range</code>异常。</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>删除操作：<br><img src="/img/opofpop.png" alt=""></p>
<p>由于删除函数不检查参数，所以必须确保要删除的元素是存在的。</p>
<p>由于删除元素会改变容器的大小，所以<code>array</code>没有删除操作。</p>
<p><code>vector</code>和<code>string</code>一样不支持<code>pop-front</code>。</p>
<p>使用<code>erase</code>函数删除<code>list</code>中的奇数元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; intelist=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=intelist.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=intelist.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">if</span>(*it%<span class="number">2</span>)</span><br><span class="line">        it=intelist.erase(it);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++it;</span><br></pre></td></tr></table></figure>

<p>要删除容器中的所有元素，既可以使用<code>clear</code>也可以使用范围内删除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slist.<span class="built_in">clear</span>();</span><br><span class="line">slist.erase(slist.<span class="built_in">begin</span>(),slist.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="forward-list的特有操作"><a href="#forward-list的特有操作" class="headerlink" title="forward_list的特有操作"></a>forward_list的特有操作</h4><p>由于<code>forward_list</code>是一个单向链表，所以是通过改变指定元素之后的元素来添加和删除元素的。</p>
<p><img src="/img/exampleofflist.png" alt=""></p>
<p><code>forward_list</code>定义了名为<code>insert_after</code>、<code>emplace_after</code>和<code>erase_after</code>的操作。例如我们要删除上面图中的<em>elem3</em>，就需要用指向<em>elem2</em>的迭代器调用<code>erase_after</code>。同时，为了能够删除首元素，<code>forward_list</code>定义了一个<strong>首前</strong>迭代器<code>before_begin</code>，为的是我们能够用这个迭代器来调用<code>erase_after</code>。</p>
<p><img src="/img/forward_listpop.png" alt=""></p>
<p>我们使用<code>erase_after</code>来删除<code>forward_list</code>中的奇数元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; flist=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> pre=flist.before_begin();</span><br><span class="line"><span class="keyword">auto</span> cur=flist.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(cur!=flist.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">if</span>(*cur*<span class="number">2</span>)</span><br><span class="line">        cur=flist.erase_after(pre);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre=cur;</span><br><span class="line">        ++cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这里，如果<code>cur</code>指向的元素是奇数，则删除<code>pre</code>之后的元素即<code>cur</code>，然后<code>cur</code>指向删除元素后的元素，<code>pre</code>仍然在<code>cur</code>的前面。如果元素不是奇数，则<code>pre</code>和<code>cur</code>都递增。</p>
<h4 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h4><p>使用<code>resize</code>函数是，如果当前大小小于要求大小，则在容器尾部添加新元素，如果大于，则删除容器后部的元素。</p>
<p><img src="/img/resize.png" alt=""></p>
<h4 id="容器操作对迭代器的影响"><a href="#容器操作对迭代器的影响" class="headerlink" title="容器操作对迭代器的影响"></a>容器操作对迭代器的影响</h4><p><img src="/img/iteratormal.png" alt=""></p>
<p>添加或删除<code>vector</code>，<code>deque</code>，<code>string</code>中的元素必须考虑迭代器失效的问题。</p>
<p>如果使用<code>insert</code>或者<code>erase</code>，就可以使得更新迭代器变得容易：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制奇数，删除偶数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it=ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=ivec.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">if</span>(*it%<span class="number">2</span>)&#123;</span><br><span class="line">        it=ivec.insert(it,*it);<span class="comment">//如果是奇数，则在其前面插入这个奇数，并且更新这个迭代器为插入的元素</span></span><br><span class="line">        it+=<span class="number">2</span>;<span class="comment">//it递增两次</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        it=ivec.erase(it);<span class="comment">//如果是偶数，则删除该元素，并更新迭代器指向后一元素</span></span><br></pre></td></tr></table></figure>

<h4 id="不要保存end返回的迭代器"><a href="#不要保存end返回的迭代器" class="headerlink" title="不要保存end返回的迭代器"></a>不要保存end返回的迭代器</h4><p>在添加或者删除<code>vector</code>或<code>string</code>的元素后，<code>end</code>返回的迭代器总是会失效，所以需要不断的更新<code>end</code>。通常实现<code>end()</code>都很快。但是要注意更新<code>end</code>，否则会带来严重的后果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们要在容器的每一个元素后添加一个新元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span>=ivec.<span class="built_in">end</span>(); </span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">begin</span>=ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it!=<span class="built_in">end</span>)</span><br><span class="line">&#123; </span><br><span class="line">    ++<span class="built_in">begin</span>; <span class="comment">//递增到下一个元素</span></span><br><span class="line">    <span class="built_in">begin</span>=ivec.insert(<span class="built_in">begin</span>,num); <span class="comment">//在前一个元素的后面插入元素，更新迭代器</span></span><br><span class="line">    ++<span class="built_in">begin</span>; <span class="comment">//递增到插入元素的后一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里在每次循环的判断条件使用的是未更新的<code>end</code>，这时保存在局部变量<code>end</code>里面的迭代器已经失效了。所以需要在每次循环结束的时候更新<code>end</code>。</p>
<h3 id="vector的增长方式"><a href="#vector的增长方式" class="headerlink" title="vector的增长方式"></a>vector的增长方式</h3><p>由于<code>vector</code>中的元素是连续存储的，所以为了避免增添元素时重新分配空间，通常会预留很大的空间作备用。</p>
<h4 id="管理容量的成员"><a href="#管理容量的成员" class="headerlink" title="管理容量的成员"></a>管理容量的成员</h4><p><code>capacity</code>和<code>reserve</code>成员可以使我们与内存分配的部分接触。</p>
<p><img src="/img/capaandres.png" alt=""></p>
<p>这里使用<code>reserve</code>函数时，如果需求空间小于当前空间，那么不执行任何操作。另外，<code>resize</code>成员也只是改变元素的数目，而不会改变容器的容量。</p>
<p>事实上，没有操作要超出<code>vector</code>的容量，<code>vector</code>就不会重新分配空间。</p>
<p>如果我们用光了容量，再次添加元素时，通常情况下会将容量增加为当前容量的一倍。</p>
<p>可以使用<code>shrink_to_fit</code>将<code>vector</code>多余的空间退回给系统：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ivec.shrink_to_fit();</span><br></pre></td></tr></table></figure>

<p>有时候标准库并不保证退还。</p>
<p>所有的分配策略都遵守一个原则：确保高效率的<code>push_back</code>操作。</p>
<h3 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h3><p>这一节关于<code>string</code>操作函数较多，主要对<code>string</code>支持的操作做一个了解。</p>
<h4 id="构造string"><a href="#构造string" class="headerlink" title="构造string"></a>构造string</h4><p><img src="/img/stringinit.png" alt=""></p>
<p>这些构造函数接受<code>string</code>和<code>const char*</code>参数。</p>
<p>如果我们从<code>const char*</code>类型指向创建字符串时，指针指向的数组必须以空字符结尾。</p>
<h4 id="substr操作"><a href="#substr操作" class="headerlink" title="substr操作"></a>substr操作</h4><p><code>substr</code>函数支持接受两个参数，一个<code>pos</code>指示开始截取字串的位置，一个<code>n</code>指示从<code>pos</code>开始往后提取的字符数。<code>n</code>的默认值为<code>s.size()-pos</code>.=。</p>
<p>另外还有改变<code>string</code>的其他操作，这里不多介绍，需要时查阅即可。</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>标准库定义了三个顺序容器适配器<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。</p>
<p>一个容器适配器接受一种已有的容器类型，使其行为看起来向另一种类型。</p>
<p>这里是所有的容器适配器都支持的操作和类型。</p>
<p><img src="/img/adapter.png" alt=""></p>
<p>每个适配器有一个默认构造函数和一个接受一个容器的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>基础上实现的。</p>
<p>我们在创建适配器时可以将一个命名的顺序容器作为第二个参数，来重载默认容器类型。</p>
<p>不同适配器对容器类型的限制：</p>
<p><img src="/img/contoadapter.png" alt=""></p>
<h5 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h5><p>栈操作：<br><img src="adapterstack.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; intStack;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> ix=<span class="number">0</span>;ix&lt;<span class="number">10</span>;ix++)</span><br><span class="line">    intStack.push(ix); <span class="comment">//保存数</span></span><br><span class="line"><span class="keyword">while</span>(!intStack.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val=intStack.top();<span class="comment">//获取栈顶元素</span></span><br><span class="line">    intStack.pop();<span class="comment">//弹出栈顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个适配器都根据底层容器的类型定义了自己的操作，比如<code>stack</code>默认以<code>deque</code>构造的，但是不能直接使用<code>push_back</code>，而只能使用<code>push</code>。</p>
<h5 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h5><p><img src="/img/queueandprior.png" alt=""></p>
<p><img src="/img/queueandprior2.png" alt=""></p>
<p><code>queue</code>使用一种先进先出的存储和访问策略。<code>priority_queue</code>会为适配器中的元素指定优先级，新加入的元素会排在所有优先级比它低的元素之前。</p>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover prev lx-cover-sm" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/footer-l.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/08/02/primer_generic-algorithm/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>primer_...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover next lx-cover-sm" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/footer-r.jpeg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/07/18/primer_io/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>primer_...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>

</div>

<footer>
  <div>
  Copyright &copy; 2019.<a href="/">Gnique Explorer</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="Gniq"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>Gniq</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>Pages</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>Friends</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
